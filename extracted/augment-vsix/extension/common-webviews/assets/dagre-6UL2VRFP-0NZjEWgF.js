import{_ as h,ar as _,as as j,at as Y,au as H,l as i,c as z,av as q,aw as K,ai as Q,an as U,aj as G,ah as V,ax as W,ay as Z,az as $}from"./mermaid-BF5da6U1.js";import{i as C,G as T}from"./graph-DEajkGTM.js";import{l as ee}from"./layout-BCBuSoBU.js";import{c as te}from"./clone-5_Q1gvFD.js";import{m as B}from"./min-BK871UjU.js";import"./debounce-BNOmQ76Y.js";import"./SimpleMonaco-BBDXOnfl.js";import"./_commonjsHelpers-CwkBNZ52.js";import"./_baseUniq-D51PL97z.js";import"./noop-CVINQ7cR.js";try{N=typeof window<"u"?window:typeof global<"u"?global:typeof globalThis<"u"?globalThis:typeof self<"u"?self:{},(k=new N.Error().stack)&&(N._sentryDebugIds=N._sentryDebugIds||{},N._sentryDebugIds[k]="4153808e-01d8-485e-ae88-ca14fc4ab169",N._sentryDebugIdIdentifier="sentry-dbid-4153808e-01d8-485e-ae88-ca14fc4ab169")}catch{}var N,k;function w(e){var r={options:{directed:e.isDirected(),multigraph:e.isMultigraph(),compound:e.isCompound()},nodes:re(e),edges:ne(e)};return C(e.graph())||(r.value=te(e.graph())),r}function re(e){return B(e.nodes(),(function(r){var t=e.node(r),d=e.parent(r),a={v:r};return C(t)||(a.value=t),C(d)||(a.parent=d),a}))}function ne(e){return B(e.edges(),(function(r){var t=e.edge(r),d={v:r.v,w:r.w};return C(r.name)||(d.name=r.name),C(t)||(d.value=t),d}))}var s=new Map,v=new Map,J=new Map,ie=h((()=>{v.clear(),J.clear(),s.clear()}),"clear"),D=h(((e,r)=>{const t=v.get(r)||[];return i.trace("In isDescendant",r," ",e," = ",t.includes(e)),t.includes(e)}),"isDescendant"),ae=h(((e,r)=>{const t=v.get(r)||[];return i.info("Descendants of ",r," is ",t),i.info("Edge is ",e),e.v!==r&&e.w!==r&&(t?t.includes(e.v)||D(e.v,r)||D(e.w,r)||t.includes(e.w):(i.debug("Tilt, ",r,",not in descendants"),!1))}),"edgeInCluster"),A=h(((e,r,t,d)=>{i.warn("Copying children of ",e,"root",d,"data",r.node(e),d);const a=r.children(e)||[];e!==d&&a.push(e),i.warn("Copying (nodes) clusterId",e,"nodes",a),a.forEach((o=>{if(r.children(o).length>0)A(o,r,t,d);else{const c=r.node(o);i.info("cp ",o," to ",d," with parent ",e),t.setNode(o,c),d!==r.parent(o)&&(i.warn("Setting parent",o,r.parent(o)),t.setParent(o,r.parent(o))),e!==d&&o!==e?(i.debug("Setting parent",o,e),t.setParent(o,e)):(i.info("In copy ",e,"root",d,"data",r.node(e),d),i.debug("Not Setting parent for node=",o,"cluster!==rootId",e!==d,"node!==clusterId",o!==e));const g=r.edges(o);i.debug("Copying Edges",g),g.forEach((f=>{i.info("Edge",f);const u=r.edge(f.v,f.w,f.name);i.info("Edge data",u,d);try{ae(f,d)?(i.info("Copying as ",f.v,f.w,u,f.name),t.setEdge(f.v,f.w,u,f.name),i.info("newGraph edges ",t.edges(),t.edge(t.edges()[0]))):i.info("Skipping copy of edge ",f.v,"-->",f.w," rootId: ",d," clusterId:",e)}catch(y){i.error(y)}}))}i.debug("Removing node",o),r.removeNode(o)}))}),"copy"),R=h(((e,r)=>{const t=r.children(e);let d=[...t];for(const a of t)J.set(a,e),d=[...d,...R(a,r)];return d}),"extractDescendants"),oe=h(((e,r,t)=>{const d=e.edges().filter((g=>g.v===r||g.w===r)),a=e.edges().filter((g=>g.v===t||g.w===t)),o=d.map((g=>({v:g.v===r?t:g.v,w:g.w===r?r:g.w}))),c=a.map((g=>({v:g.v,w:g.w})));return o.filter((g=>c.some((f=>g.v===f.v&&g.w===f.w))))}),"findCommonEdges"),x=h(((e,r,t)=>{const d=r.children(e);if(i.trace("Searching children of id ",e,d),d.length<1)return e;let a;for(const o of d){const c=x(o,r,t),g=oe(r,t,c);if(c){if(!(g.length>0))return c;a=c}}return a}),"findNonClusterChild"),P=h((e=>s.has(e)&&s.get(e).externalConnections&&s.has(e)?s.get(e).id:e),"getAnchorId"),de=h(((e,r)=>{if(!e||r>10)i.debug("Opting out, no graph ");else{i.debug("Opting in, graph "),e.nodes().forEach((function(t){e.children(t).length>0&&(i.warn("Cluster identified",t," Replacement id in edges: ",x(t,e,t)),v.set(t,R(t,e)),s.set(t,{id:x(t,e,t),clusterData:e.node(t)}))})),e.nodes().forEach((function(t){const d=e.children(t),a=e.edges();d.length>0?(i.debug("Cluster identified",t,v),a.forEach((o=>{D(o.v,t)^D(o.w,t)&&(i.warn("Edge: ",o," leaves cluster ",t),i.warn("Descendants of XXX ",t,": ",v.get(t)),s.get(t).externalConnections=!0)}))):i.debug("Not a cluster ",t,v)}));for(let t of s.keys()){const d=s.get(t).id,a=e.parent(d);a!==t&&s.has(a)&&!s.get(a).externalConnections&&(s.get(t).id=a)}e.edges().forEach((function(t){const d=e.edge(t);i.warn("Edge "+t.v+" -> "+t.w+": "+JSON.stringify(t)),i.warn("Edge "+t.v+" -> "+t.w+": "+JSON.stringify(e.edge(t)));let a=t.v,o=t.w;if(i.warn("Fix XXX",s,"ids:",t.v,t.w,"Translating: ",s.get(t.v)," --- ",s.get(t.w)),s.get(t.v)||s.get(t.w)){if(i.warn("Fixing and trying - removing XXX",t.v,t.w,t.name),a=P(t.v),o=P(t.w),e.removeEdge(t.v,t.w,t.name),a!==t.v){const c=e.parent(a);s.get(c).externalConnections=!0,d.fromCluster=t.v}if(o!==t.w){const c=e.parent(o);s.get(c).externalConnections=!0,d.toCluster=t.w}i.warn("Fix Replacing with XXX",a,o,t.name),e.setEdge(a,o,d,t.name)}})),i.warn("Adjusted Graph",w(e)),F(e,0),i.trace(s)}}),"adjustClustersAndEdges"),F=h(((e,r)=>{if(i.warn("extractor - ",r,w(e),e.children("D")),r>10)return void i.error("Bailing out");let t=e.nodes(),d=!1;for(const a of t){const o=e.children(a);d=d||o.length>0}if(d){i.debug("Nodes = ",t,r);for(const a of t)if(i.debug("Extracting node",a,s,s.has(a)&&!s.get(a).externalConnections,!e.parent(a),e.node(a),e.children("D")," Depth ",r),s.has(a))if(!s.get(a).externalConnections&&e.children(a)&&e.children(a).length>0){i.warn("Cluster without external connections, without a parent and with children",a,r);let o=e.graph().rankdir==="TB"?"LR":"TB";s.get(a)?.clusterData?.dir&&(o=s.get(a).clusterData.dir,i.warn("Fixing dir",s.get(a).clusterData.dir,o));const c=new T({multigraph:!0,compound:!0}).setGraph({rankdir:o,nodesep:50,ranksep:50,marginx:8,marginy:8}).setDefaultEdgeLabel((function(){return{}}));i.warn("Old graph before copy",w(e)),A(a,e,c,a),e.setNode(a,{clusterNode:!0,id:a,clusterData:s.get(a).clusterData,label:s.get(a).label,graph:c}),i.warn("New graph after copy node: (",a,")",w(c)),i.debug("Old graph after copy",w(e))}else i.warn("Cluster ** ",a," **not meeting the criteria !externalConnections:",!s.get(a).externalConnections," no parent: ",!e.parent(a)," children ",e.children(a)&&e.children(a).length>0,e.children("D"),r),i.debug(s);else i.debug("Not a cluster",a,r);t=e.nodes(),i.warn("New list of nodes",t);for(const a of t){const o=e.node(a);i.warn(" Now next level",a,o),o?.clusterNode&&F(o.graph,r+1)}}else i.debug("Done, no node has children",e.nodes())}),"extractor"),L=h(((e,r)=>{if(r.length===0)return[];let t=Object.assign([],r);return r.forEach((d=>{const a=e.children(d),o=L(e,a);t=[...t,...o]})),t}),"sorter"),se=h((e=>L(e,e.children())),"sortNodesByHierarchy"),M=h((async(e,r,t,d,a,o)=>{i.warn("Graph in recursive render:XAX",w(r),a);const c=r.graph().rankdir;i.trace("Dir in recursive render - dir:",c);const g=e.insert("g").attr("class","root");r.nodes()?i.info("Recursive render XXX",r.nodes()):i.info("No nodes found for",r),r.edges().length>0&&i.info("Recursive edges",r.edge(r.edges()[0]));const f=g.insert("g").attr("class","clusters"),u=g.insert("g").attr("class","edgePaths"),y=g.insert("g").attr("class","edgeLabels"),m=g.insert("g").attr("class","nodes");await Promise.all(r.nodes().map((async function(l){const n=r.node(l);if(a!==void 0){const p=JSON.parse(JSON.stringify(a.clusterData));i.trace(`Setting data for parent cluster XXX
 Node.id = `,l,`
 data=`,p.height,`
Parent cluster`,a.height),r.setNode(a.id,p),r.parent(l)||(i.trace("Setting parent",l,a.id),r.setParent(l,a.id,p))}if(i.info("(Insert) Node XXX"+l+": "+JSON.stringify(r.node(l))),n?.clusterNode){i.info("Cluster identified XBX",l,n.width,r.node(l));const{ranksep:p,nodesep:b}=r.graph();n.graph.setGraph({...n.graph.graph(),ranksep:p+25,nodesep:b});const E=await M(m,n.graph,t,d,r.node(l),o),S=E.elem;q(n,S),n.diff=E.diff||0,i.info("New compound node after recursive render XAX",l,"width",n.width,"height",n.height),K(S,n)}else r.children(l).length>0?(i.trace("Cluster - the non recursive path XBX",l,n.id,n,n.width,"Graph:",r),i.trace(x(n.id,r)),s.set(n.id,{id:x(n.id,r),node:n})):(i.trace("Node - the non recursive path XAX",l,m,r.node(l),c),await Q(m,r.node(l),{config:o,dir:c}))}))),await h((async()=>{const l=r.edges().map((async function(n){const p=r.edge(n.v,n.w,n.name);i.info("Edge "+n.v+" -> "+n.w+": "+JSON.stringify(n)),i.info("Edge "+n.v+" -> "+n.w+": ",n," ",JSON.stringify(r.edge(n))),i.info("Fix",s,"ids:",n.v,n.w,"Translating: ",s.get(n.v),s.get(n.w)),await $(y,p)}));await Promise.all(l)}),"processEdges")(),i.info("Graph before layout:",JSON.stringify(w(r))),i.info("############################################# XXX"),i.info("###                Layout                 ### XXX"),i.info("############################################# XXX"),ee(r),i.info("Graph after layout:",JSON.stringify(w(r)));let O=0,{subGraphTitleTotalMargin:I}=U(o);return await Promise.all(se(r).map((async function(l){const n=r.node(l);if(i.info("Position XBX => "+l+": ("+n.x,","+n.y,") width: ",n.width," height: ",n.height),n?.clusterNode)n.y+=I,i.info("A tainted cluster node XBX1",l,n.id,n.width,n.height,n.x,n.y,r.parent(l)),s.get(n.id).node=n,G(n);else if(r.children(l).length>0){i.info("A pure cluster node XBX1",l,n.id,n.x,n.y,n.width,n.height,r.parent(l)),n.height+=I,r.node(n.parentId);const p=n?.padding/2||0,b=n?.labelBBox?.height||0,E=b-p||0;i.debug("OffsetY",E,"labelHeight",b,"halfPadding",p),await V(f,n),s.get(n.id).node=n}else{const p=r.node(n.parentId);n.y+=I/2,i.info("A regular node XBX1 - using the padding",n.id,"parent",n.parentId,n.width,n.height,n.x,n.y,"offsetY",n.offsetY,"parent",p,p?.offsetY,n),G(n)}}))),r.edges().forEach((function(l){const n=r.edge(l);i.info("Edge "+l.v+" -> "+l.w+": "+JSON.stringify(n),n),n.points.forEach((S=>S.y+=I/2));const p=r.node(l.v);var b=r.node(l.w);const E=W(u,n,s,t,p,b,d);Z(n,E)})),r.nodes().forEach((function(l){const n=r.node(l);i.info(l,n.type,n.diff),n.isGroup&&(O=n.diff)})),i.warn("Returning from recursive render XAX",g,O),{elem:g,diff:O}}),"recursiveRender"),ve=h((async(e,r)=>{const t=new T({multigraph:!0,compound:!0}).setGraph({rankdir:e.direction,nodesep:e.config?.nodeSpacing||e.config?.flowchart?.nodeSpacing||e.nodeSpacing,ranksep:e.config?.rankSpacing||e.config?.flowchart?.rankSpacing||e.rankSpacing,marginx:8,marginy:8}).setDefaultEdgeLabel((function(){return{}})),d=r.select("g");_(d,e.markers,e.type,e.diagramId),j(),Y(),H(),ie(),e.nodes.forEach((o=>{t.setNode(o.id,{...o}),o.parentId&&t.setParent(o.id,o.parentId)})),i.debug("Edges:",e.edges),e.edges.forEach((o=>{if(o.start===o.end){const c=o.start,g=c+"---"+c+"---1",f=c+"---"+c+"---2",u=t.node(c);t.setNode(g,{domId:g,id:g,parentId:u.parentId,labelStyle:"",label:"",padding:0,shape:"labelRect",style:"",width:10,height:10}),t.setParent(g,u.parentId),t.setNode(f,{domId:f,id:f,parentId:u.parentId,labelStyle:"",padding:0,shape:"labelRect",label:"",style:"",width:10,height:10}),t.setParent(f,u.parentId);const y=structuredClone(o),m=structuredClone(o),X=structuredClone(o);y.label="",y.arrowTypeEnd="none",y.id=c+"-cyclic-special-1",m.arrowTypeStart="none",m.arrowTypeEnd="none",m.id=c+"-cyclic-special-mid",X.label="",u.isGroup&&(y.fromCluster=c,X.toCluster=c),X.id=c+"-cyclic-special-2",X.arrowTypeStart="none",t.setEdge(c,g,y,c+"-cyclic-special-0"),t.setEdge(g,f,m,c+"-cyclic-special-1"),t.setEdge(f,c,X,c+"-cyc<lic-special-2")}else t.setEdge(o.start,o.end,{...o},o.id)})),i.warn("Graph at first:",JSON.stringify(w(t))),de(t),i.warn("Graph after XAX:",JSON.stringify(w(t)));const a=z();await M(d,t,e.type,e.diagramId,void 0,a)}),"render");export{ve as render};
//# sourceMappingURL=dagre-6UL2VRFP-0NZjEWgF.js.map
