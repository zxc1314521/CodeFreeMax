"use strict";

const { debug, warn } = require("../infra/log");
const { normalizeEndpoint, normalizeString } = require("../infra/util");

const CONFIG_KEY = "augment-byok.config.v1";

function isValidHistorySummaryTemplateNewMode(template) {
  const s = normalizeString(template);
  if (!s) return false;
  const required = [
    "{summary}",
    "{summarization_request_id}",
    "{beginning_part_dropped_num_exchanges}",
    "{middle_part_abridged}",
    "{end_part_full}"
  ];
  return required.every((p) => s.includes(p));
}

function defaultConfig() {
  return {
    version: 1,
    official: {
      completionUrl: "https://api.augmentcode.com/",
      apiToken: ""
    },
    historySummary: {
      enabled: false,
      providerId: "",
      model: "",
      maxTokens: 1024,
      timeoutSeconds: 60,
      triggerOnHistorySizeChars: 800000,
      triggerStrategy: "auto",
      triggerOnContextRatio: 0.7,
      targetContextRatio: 0.55,
      contextWindowTokensDefault: 0,
      contextWindowTokensOverrides: {},
      historyTailSizeCharsToExclude: 250000,
      minTailExchanges: 2,
      cacheTtlMs: 0,
      maxSummarizationInputChars: 250000,
      prompt: "You are performing a CONTEXT CHECKPOINT COMPACTION. Create a handoff summary for another LLM that will resume the task.\n\nInclude:\n- Current progress and key decisions made\n- Important context, constraints, or user preferences\n- What remains to be done (clear next steps)\n- Any critical data, examples, or references needed to continue\n\nBe concise, structured, and focused on helping the next LLM seamlessly continue the work.",
      rollingSummary: true,
      summaryNodeRequestMessageTemplate: "<supervisor>\nThis is a continuation of the conversation that Agent(you) had with the user.\n\nHere is the summary of whole conversation history that was generated by Agent(you) so 'I' in the summary represents Agent(you).\n<summary request_id=\"{summarization_request_id}\">\n{summary}\n</summary>\n\nThe whole previous conversation history was split into three parts:\n- beginning. Information from this part is only present in the compressed form in the summary above. This part is not shown neither in abridged nor in full form below to reduce context size. This part can be empty if the whole conversation was short enough.\n- middle. This part is present in the abridged form below.\n- end. This part is present in full form below.\n\nBeginning part has {beginning_part_dropped_num_exchanges} exchanges.\n\n<middle_part_abridged>\n{middle_part_abridged}\n</middle_part_abridged>\n\n<end_part_full>\n{end_part_full}\n</end_part_full>\n\nContinue the conversation and finish the task given by the user from this point.\n</supervisor>",
      abridgedHistoryParams: {
        totalCharsLimit: 10000,
        userMessageCharsLimit: 1000,
        agentResponseCharsLimit: 2000,
        actionCharsLimit: 200,
        numFilesModifiedLimit: 10,
        numFilesCreatedLimit: 10,
        numFilesDeletedLimit: 10,
        numFilesViewedLimit: 10,
        numTerminalCommandsLimit: 10
      }
    },
    providers: [
      {
        id: "openai",
        type: "openai_compatible",
        baseUrl: "https://api.openai.com/v1",
        apiKey: "",
        models: ["gpt-4o-mini"],
        defaultModel: "gpt-4o-mini",
        headers: {},
        requestDefaults: {}
      },
      {
        id: "anthropic",
        type: "anthropic",
        baseUrl: "https://api.anthropic.com/v1",
        apiKey: "",
        models: ["claude-3-5-sonnet-20241022"],
        defaultModel: "claude-3-5-sonnet-20241022",
        headers: {},
        requestDefaults: {}
      }
    ],
    routing: {
      rules: {
        "/get-models": { mode: "byok" },
        "/chat": { mode: "byok" },
        "/chat-stream": { mode: "byok" },
        "/prompt-enhancer": { mode: "byok" },
        "/completion": { mode: "disabled" },
        "/chat-input-completion": { mode: "byok" },
        "/edit": { mode: "byok" },
        "/instruction-stream": { mode: "byok" },
        "/smart-paste-stream": { mode: "byok" },
        "/next-edit-stream": { mode: "byok" },
        "/generate-commit-message-stream": { mode: "byok" },
        "/generate-conversation-title": { mode: "byok" },
        "/next_edit_loc": { mode: "byok" },

        "/user-secrets/list": { mode: "disabled" },
        "/user-secrets/upsert": { mode: "disabled" },
        "/user-secrets/delete": { mode: "disabled" },

        "/client-metrics": { mode: "disabled" },
        "/client-completion-timelines": { mode: "disabled" },
        "/record-preference-sample": { mode: "disabled" },
        "/record-request-events": { mode: "official" },
        "/record-session-events": { mode: "disabled" },
        "/record-user-events": { mode: "disabled" },
        "/report-error": { mode: "official" },
        "/resolve-completions": { mode: "disabled" },
        "/resolve-edit": { mode: "disabled" },
        "/resolve-instruction": { mode: "disabled" }
      }
    },
    telemetry: {
      disabledEndpoints: []
    }
  };
}

function get(obj, keys) {
  for (const k of keys) {
    if (obj && typeof obj === "object" && Object.prototype.hasOwnProperty.call(obj, k)) return obj[k];
  }
  return undefined;
}

function normalizeListStrings(v) {
  const arr = Array.isArray(v) ? v : [];
  const out = [];
  for (const it of arr) {
    const s = normalizeString(it);
    if (s) out.push(s);
  }
  return Array.from(new Set(out));
}

function normalizeMode(v) {
  const s = normalizeString(v);
  if (s === "byok" || s === "official" || s === "disabled") return s;
  return "";
}

function normalizeConfig(raw) {
  const out = defaultConfig();
  if (!raw || typeof raw !== "object" || Array.isArray(raw)) return out;

  const version = get(raw, ["version"]);
  if (Number.isFinite(Number(version)) && Number(version) > 0) out.version = Number(version);

  const official = get(raw, ["official"]);
  const completionUrl = normalizeString(get(official, ["completion_url", "completionUrl"]));
  if (completionUrl) out.official.completionUrl = completionUrl;
  const apiToken = normalizeString(get(official, ["api_token", "apiToken"]));
  if (apiToken) out.official.apiToken = apiToken;

  const telemetry = get(raw, ["telemetry"]);
  const disabledEndpoints = get(telemetry, ["disabled_endpoints", "disabledEndpoints"]);
  if (Array.isArray(disabledEndpoints)) out.telemetry.disabledEndpoints = disabledEndpoints.map(normalizeEndpoint).filter(Boolean);

  const historySummary = get(raw, ["history_summary", "historySummary"]);
  if (historySummary && typeof historySummary === "object" && !Array.isArray(historySummary)) {
    const hs = out.historySummary;
    const enabled = get(historySummary, ["enabled"]);
    if (typeof enabled === "boolean") hs.enabled = enabled;
    const providerId = normalizeString(get(historySummary, ["provider_id", "providerId"]));
    if (providerId) hs.providerId = providerId;
    const model = normalizeString(get(historySummary, ["model"]));
    if (model) hs.model = model;
    const maxTokens = get(historySummary, ["max_tokens", "maxTokens"]);
    if (Number.isFinite(Number(maxTokens)) && Number(maxTokens) > 0) hs.maxTokens = Math.floor(Number(maxTokens));
    const timeoutSeconds = get(historySummary, ["timeout_seconds", "timeoutSeconds"]);
    if (Number.isFinite(Number(timeoutSeconds)) && Number(timeoutSeconds) > 0) hs.timeoutSeconds = Math.floor(Number(timeoutSeconds));
    const triggerOnHistorySizeChars = get(historySummary, ["trigger_on_history_size_chars", "triggerOnHistorySizeChars"]);
    if (Number.isFinite(Number(triggerOnHistorySizeChars)) && Number(triggerOnHistorySizeChars) > 0) hs.triggerOnHistorySizeChars = Math.floor(Number(triggerOnHistorySizeChars));
    const triggerStrategy = normalizeString(get(historySummary, ["trigger_strategy", "triggerStrategy"]));
    if (triggerStrategy) hs.triggerStrategy = triggerStrategy;
    const triggerOnContextRatio = get(historySummary, ["trigger_on_context_ratio", "triggerOnContextRatio"]);
    if (Number.isFinite(Number(triggerOnContextRatio)) && Number(triggerOnContextRatio) > 0) hs.triggerOnContextRatio = Number(triggerOnContextRatio);
    const targetContextRatio = get(historySummary, ["target_context_ratio", "targetContextRatio"]);
    if (Number.isFinite(Number(targetContextRatio)) && Number(targetContextRatio) > 0) hs.targetContextRatio = Number(targetContextRatio);
    const contextWindowTokensDefault = get(historySummary, ["context_window_tokens_default", "contextWindowTokensDefault"]);
    if (Number.isFinite(Number(contextWindowTokensDefault)) && Number(contextWindowTokensDefault) >= 0) hs.contextWindowTokensDefault = Math.floor(Number(contextWindowTokensDefault));
    const contextWindowTokensOverrides = get(historySummary, ["context_window_tokens_overrides", "contextWindowTokensOverrides"]);
    if (contextWindowTokensOverrides && typeof contextWindowTokensOverrides === "object" && !Array.isArray(contextWindowTokensOverrides)) hs.contextWindowTokensOverrides = contextWindowTokensOverrides;
    const historyTailSizeCharsToExclude = get(historySummary, ["history_tail_size_chars_to_exclude", "historyTailSizeCharsToExclude"]);
    if (Number.isFinite(Number(historyTailSizeCharsToExclude)) && Number(historyTailSizeCharsToExclude) >= 0) hs.historyTailSizeCharsToExclude = Math.floor(Number(historyTailSizeCharsToExclude));
    const minTailExchanges = get(historySummary, ["min_tail_exchanges", "minTailExchanges"]);
    if (Number.isFinite(Number(minTailExchanges)) && Number(minTailExchanges) > 0) hs.minTailExchanges = Math.floor(Number(minTailExchanges));
    const cacheTtlMs = get(historySummary, ["cache_ttl_ms", "cacheTtlMs"]);
    if (Number.isFinite(Number(cacheTtlMs)) && Number(cacheTtlMs) >= 0) hs.cacheTtlMs = Math.floor(Number(cacheTtlMs));
    const maxSummarizationInputChars = get(historySummary, ["max_summarization_input_chars", "maxSummarizationInputChars"]);
    if (Number.isFinite(Number(maxSummarizationInputChars)) && Number(maxSummarizationInputChars) >= 0) hs.maxSummarizationInputChars = Math.floor(Number(maxSummarizationInputChars));
    const prompt = typeof get(historySummary, ["prompt"]) === "string" ? get(historySummary, ["prompt"]) : "";
    if (normalizeString(prompt)) hs.prompt = prompt;
    const rollingSummary = get(historySummary, ["rolling_summary", "rollingSummary"]);
    if (typeof rollingSummary === "boolean") hs.rollingSummary = rollingSummary;
    const template =
      typeof get(historySummary, ["summary_node_request_message_template", "summaryNodeRequestMessageTemplate"]) === "string"
        ? get(historySummary, ["summary_node_request_message_template", "summaryNodeRequestMessageTemplate"])
        : "";
    if (normalizeString(template)) {
      if (!isValidHistorySummaryTemplateNewMode(template)) {
        warn("historySummary.summaryNodeRequestMessageTemplate 无效（要求包含 {summary}/{summarization_request_id}/{beginning_part_dropped_num_exchanges}/{middle_part_abridged}/{end_part_full}），将使用默认模板");
      } else {
        hs.summaryNodeRequestMessageTemplate = template;
      }
    }
    const abridgedHistoryParams = get(historySummary, ["abridged_history_params", "abridgedHistoryParams"]);
    if (abridgedHistoryParams && typeof abridgedHistoryParams === "object" && !Array.isArray(abridgedHistoryParams)) {
      const p = hs.abridgedHistoryParams;
      const totalCharsLimit = get(abridgedHistoryParams, ["total_chars_limit", "totalCharsLimit"]);
      if (Number.isFinite(Number(totalCharsLimit)) && Number(totalCharsLimit) > 0) p.totalCharsLimit = Math.floor(Number(totalCharsLimit));
      const userMessageCharsLimit = get(abridgedHistoryParams, ["user_message_chars_limit", "userMessageCharsLimit"]);
      if (Number.isFinite(Number(userMessageCharsLimit)) && Number(userMessageCharsLimit) > 0) p.userMessageCharsLimit = Math.floor(Number(userMessageCharsLimit));
      const agentResponseCharsLimit = get(abridgedHistoryParams, ["agent_response_chars_limit", "agentResponseCharsLimit"]);
      if (Number.isFinite(Number(agentResponseCharsLimit)) && Number(agentResponseCharsLimit) > 0) p.agentResponseCharsLimit = Math.floor(Number(agentResponseCharsLimit));
      const actionCharsLimit = get(abridgedHistoryParams, ["action_chars_limit", "actionCharsLimit"]);
      if (Number.isFinite(Number(actionCharsLimit)) && Number(actionCharsLimit) > 0) p.actionCharsLimit = Math.floor(Number(actionCharsLimit));
      const numFilesModifiedLimit = get(abridgedHistoryParams, ["num_files_modified_limit", "numFilesModifiedLimit"]);
      if (Number.isFinite(Number(numFilesModifiedLimit)) && Number(numFilesModifiedLimit) > 0) p.numFilesModifiedLimit = Math.floor(Number(numFilesModifiedLimit));
      const numFilesCreatedLimit = get(abridgedHistoryParams, ["num_files_created_limit", "numFilesCreatedLimit"]);
      if (Number.isFinite(Number(numFilesCreatedLimit)) && Number(numFilesCreatedLimit) > 0) p.numFilesCreatedLimit = Math.floor(Number(numFilesCreatedLimit));
      const numFilesDeletedLimit = get(abridgedHistoryParams, ["num_files_deleted_limit", "numFilesDeletedLimit"]);
      if (Number.isFinite(Number(numFilesDeletedLimit)) && Number(numFilesDeletedLimit) > 0) p.numFilesDeletedLimit = Math.floor(Number(numFilesDeletedLimit));
      const numFilesViewedLimit = get(abridgedHistoryParams, ["num_files_viewed_limit", "numFilesViewedLimit"]);
      if (Number.isFinite(Number(numFilesViewedLimit)) && Number(numFilesViewedLimit) > 0) p.numFilesViewedLimit = Math.floor(Number(numFilesViewedLimit));
      const numTerminalCommandsLimit = get(abridgedHistoryParams, ["num_terminal_commands_limit", "numTerminalCommandsLimit"]);
      if (Number.isFinite(Number(numTerminalCommandsLimit)) && Number(numTerminalCommandsLimit) > 0) p.numTerminalCommandsLimit = Math.floor(Number(numTerminalCommandsLimit));
    }
  }

  const routing = get(raw, ["routing"]);

  const rules = get(routing, ["rules"]);
  if (rules && typeof rules === "object" && !Array.isArray(rules)) {
    out.routing.rules = {};
    for (const [k, v] of Object.entries(rules)) {
      const ep = normalizeEndpoint(k);
      if (!ep) continue;
      const mode = normalizeMode(get(v, ["mode"])) || "official";
      const providerId = normalizeString(get(v, ["provider_id", "providerId"]));
      const model = normalizeString(get(v, ["model"]));
      out.routing.rules[ep] = { mode, providerId, model };
    }
  }

  const providers = get(raw, ["providers"]);
  if (Array.isArray(providers)) {
    out.providers = providers
      .map((p) => {
        if (!p || typeof p !== "object" || Array.isArray(p)) return null;
        const id = normalizeString(get(p, ["id"]));
        const type = normalizeString(get(p, ["type"]));
        const baseUrl = normalizeString(get(p, ["base_url", "baseUrl"]));
        const apiKey = normalizeString(get(p, ["api_key", "apiKey"]));
        const defaultModel = normalizeString(get(p, ["default_model", "defaultModel"]));
        const models = normalizeListStrings(get(p, ["models"]));
        const headers = get(p, ["headers"]);
        const requestDefaults = get(p, ["request_defaults", "requestDefaults"]);
        if (!id || !type) return null;

        const finalModels = models.length ? models : defaultModel ? [defaultModel] : [];
        const finalDefaultModel = defaultModel || finalModels[0] || "";

        return {
          id,
          type,
          baseUrl,
          apiKey,
          models: finalModels,
          defaultModel: finalDefaultModel,
          headers: headers && typeof headers === "object" && !Array.isArray(headers) ? headers : {},
          requestDefaults: requestDefaults && typeof requestDefaults === "object" && !Array.isArray(requestDefaults) ? requestDefaults : {}
        };
      })
      .filter(Boolean);
  }

  return out;
}

class ConfigManager {
  constructor() {
    this.current = defaultConfig();
    this.lastGood = this.current;
    this.lastError = null;
    this._ctx = null;
  }

  attachContext(ctx) {
    this._ctx = ctx || null;
    return this.reloadNow("attachContext");
  }

  get() {
    return this.current;
  }

  getStorageKey() {
    return CONFIG_KEY;
  }

  reloadNow(reason) {
    const ctx = this._ctx;
    if (!ctx || !ctx.globalState || typeof ctx.globalState.get !== "function") {
      this.lastError = new Error("config storage not ready (missing extension context)");
      this.current = this.lastGood;
      debug(`config reload skipped (${reason}): no ctx`);
      return { ok: false, reason: "no_ctx" };
    }

    try {
      const raw = ctx.globalState.get(CONFIG_KEY);
      if (!raw) {
        this.lastError = new Error("config missing (will initialize defaults on next save)");
        this.current = this.lastGood;
        debug(`config missing (${reason})`);
        return { ok: false, reason: "missing" };
      }
      const cfg = normalizeConfig(raw);
      this.current = cfg;
      this.lastGood = cfg;
      this.lastError = null;
      debug(`config loaded (${reason})`);
      return { ok: true };
    } catch (err) {
      this.lastError = err instanceof Error ? err : new Error(String(err));
      this.current = this.lastGood;
      warn(`config load failed (${reason}): ${this.lastError.message}`);
      return { ok: false, reason: "error", error: this.lastError };
    }
  }

  async saveNow(raw, reason) {
    const ctx = this._ctx;
    if (!ctx || !ctx.globalState || typeof ctx.globalState.update !== "function") throw new Error("config storage not ready (missing globalState)");
    const cfg = normalizeConfig(raw);
    await ctx.globalState.update(CONFIG_KEY, cfg);
    this.current = cfg;
    this.lastGood = cfg;
    this.lastError = null;
    debug(`config saved (${normalizeString(reason) || "save"})`);
    return { ok: true, config: cfg };
  }

  async resetNow(reason) {
    return await this.saveNow(defaultConfig(), normalizeString(reason) || "reset");
  }
}

function createConfigManager(opts) {
  const mgr = new ConfigManager();
  const ctx = opts && typeof opts === "object" ? opts.ctx : null;
  if (ctx) mgr.attachContext(ctx);
  return mgr;
}

module.exports = { defaultConfig, createConfigManager };
